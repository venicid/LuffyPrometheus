> 轮询

- “轮询”是指不管服务端数据有无更新，客户端每隔定长时间请求拉取一次数据，可能有更新数据返回，也可能什么都没有。配置中心如果使用「轮询」实现动态推送，会有以下问题：
- 推送延迟：客户端每隔 5s 拉取一次配置，若配置变更发生在第 6s，则配置推送的延迟会达到 4s
- 服务端压力：配置一般不会发生变化，频繁的轮询会给服务端造成很大的压力。
- 推送延迟和服务端压力无法中和降低轮询的间隔，延迟降低，压力增加；增加轮询的间隔，压力降低，延迟增高。


> 什么是长轮询 long polling 
- “长轮询”则不存在上述的问题。客户端发起长轮询，如果服务端的数据没有发生变更，会 hold 住请求，直到服务端的数据发生变化，或者等待一定时间超时才会返回。返回后，客户端又会立即再次发起下一次长轮询。配置中心使用「长轮询」如何解决「轮询」遇到的问题也就显而易见了：

- 推送延迟。服务端数据发生变更后，长轮询结束，立刻返回响应给客户端。
- 服务端压力。长轮询的间隔期一般很长，例如 30s、60s，并且服务端 hold 住连接不会消耗太多服务端资源。

> watch机制
- consul中的watch可以监听service，kv，check，event等事件的变化，实时获取最新的数据。 consul支持以下watch类型：
    - key 监听一个consul kv中的key
    - keyprefix 监听consul kv中的key的前缀
    - services 监听有效服务的变化
    - nodes 监听节点的变化
    - service 监听服务的变化
    - checks 监听check的变化
    - event 监听自定义事件的变化
- 从以上可以看出consul提供非常丰富的监听类型，通过这些类型我们可以实时观测到consul整个集群中的变化，从而实现一些特别的需求，比如：服务告警，配置实时更新等功能。


> watch 其实是通过使用支持 *blocking queries* 的HTTP API来实现的

 

> consul blocking query
- 文档地址 https://www.consul.io/api-docs/features/blocking
- Consul中的许多端点都支持一种称为“阻止查询”的功能
- 阻塞查询用于等待使用长轮询的潜在更改
- 发出一个block query时，服务端的处理流程为:
    - 如果wait时间没有超时
        - 如果index大于服务内部的index
            - 如果服务在此期间有变更，则重新获取服务的数据。重新判断
            - 如果服务没有变更，则等待
        - 如果index小于服务内部的index，则立即返回，并通过header设置客户端的index
    - 如果wait时间超时
        - 直接返回当前的服务数据





